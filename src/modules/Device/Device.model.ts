import mongoose, { Schema } from 'mongoose';
import { PORT_STATUS } from '../../utils/constants/port';

// ðŸ”¹ Subschemas
const CalibrationSchema = new Schema(
  {
    scaling: { type: Number, default: 1 },
    offset: { type: Number, default: 0 },
  },
  { _id: false },
);

const ThresholdSchema = new Schema(
  {
    min: Number,
    max: Number,
    message: String,
  },
  { _id: false },
);

const ModbusReadSchema = new Schema(
  {
    readId: {
      type: String,
      required: true,
      immutable: true, // ðŸ”’ Auto-generated by backend, never changes
    },
    slaveId: {
      type: String,
      required: true,
      immutable: true, // ðŸ”’ Reference to parent slave
    },
    portKey: { type: String, required: true }, // ðŸ”‘ virtual port
    registerType: {
      type: String,
      enum: ['holding', 'input', 'coil', 'discrete'],
    },
    functionCode: {
      type: String,
      enum: ['fc_1', 'fc_2', 'fc_3', 'fc_4'],
      required: true,
      // fc_1: Read Coils (registerType: coil)
      // fc_2: Read Discrete Inputs (registerType: discrete)
      // fc_3: Read Holding Registers (registerType: holding)
      // fc_4: Read Input Registers (registerType: input)
    },
    startAddress: { type: Number, required: true },
    bitsToRead: { type: Number, required: true },
    name: { type: String, required: true },
    description: { type: String },
    scaling: { type: Number, default: 1 },
    offset: { type: Number, default: 0 },
    unit: { type: String },
    tag: { type: String },
    dataType: { type: String },
    endianness: {
      type: String,
      enum: ['ABCD ', 'CDAB ', 'BADC ', 'DCBA', 'NONE'],
      default: 'NONE',
    },
  },
  { _id: false },
);

const ModbusSlaveSchema = new Schema({
  slaveId: {
    type: String,
    required: true,
    immutable: true, // ðŸ”’ Auto-generated by backend, never changes
  },
  portKey: {
    type: String,
    required: true,
    immutable: true, // ðŸ”’ Reference to parent port (from DeviceModel)
  },
  name: { type: String, required: true },
  serial: {
    baudRate: { type: Number, required: true },
    dataBits: { type: Number, required: true },
    stopBits: { type: Number, required: true },
    parity: { type: String, enum: ['none', 'even', 'odd'], required: true },
  },
  polling: {
    intervalMs: { type: Number, required: true },
    timeoutMs: { type: Number, required: true },
    retries: { type: Number, required: true },
  },
  reads: [ModbusReadSchema],
});

const PortSchema = new Schema(
  {
    portKey: { type: String, required: true },
    name: { type: String, required: true },
    portType: { type: Schema.Types.ObjectId, ref: 'PortType', required: true },
    unit: { type: String, default: '' },
    calibrationValue: CalibrationSchema,
    status: { type: String, enum: Object.keys(PORT_STATUS) },
    thresholds: ThresholdSchema,
    modbusSlaves: [ModbusSlaveSchema], // Only used for Modbus ports
  },
  { _id: false },
);

// ðŸ”¹ Deployment Schema
const DeploymentSchema = new Schema(
  {
    status: { type: String, enum: ['pending', 'sent', 'saved', 'error'], default: 'pending' },
    errorMessage: { type: String, default: null, required: false },
    sentAt: Date,
    savedAt: Date,
  },
  { _id: false },
);

// ðŸ”¹ Main Device Schema
const DeviceSchema = new Schema(
  {
    configId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    imei: { type: String, required: true, unique: true },
    deviceModelId: { type: Schema.Types.ObjectId, ref: 'DeviceModel', required: true },
    organizationId: { type: Schema.Types.ObjectId, ref: 'Organization' },
    status: { type: String, enum: ['online', 'offline', 'maintenance'], default: 'offline' },
    location: { lat: Number, lng: Number, address: String },
    metadata: { type: Schema.Types.Mixed },
    ports: [PortSchema],
    pointOfContact: String,
    alertEmails: [String],
    alertPhones: [String],
    assignedAt: Date,
    lastSeen: Date,
    manufacturingYear: Date,
    deployment: DeploymentSchema,
  },
  { timestamps: true },
);

DeviceSchema.index({ imei: 1 }, { unique: true });

export const Device = mongoose.model('Device', DeviceSchema);
